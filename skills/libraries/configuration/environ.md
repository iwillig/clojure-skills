---
name: environ
description: |
  Manage environment settings from multiple sources with Environ following 12 Factor App principles.
  Use when loading configuration from environment variables, Java system properties, Leiningen profiles,
  or Boot build settings. Use when the user mentions environ, environment variables, env vars, 12 factor,
  configuration, settings, dev/test/prod environments, or deployment configuration.
sources:
  - https://github.com/weavejester/environ
  - https://cljdoc.org/d/environ/environ/1.2.0
---

# Environ

Environ is a lightweight library for managing environment settings from multiple sources, designed for applications following the [12 Factor App](http://12factor.net/) pattern.

## Quick Start

Environ provides a simple map of environment settings:

```clojure
(require '[environ.core :refer [env]])

;; Access environment variables
(def database-url
  (env :database-url))
;; => "jdbc:postgresql://localhost/mydb"

;; With default fallback
(def port
  (or (env :port) 3000))
;; => 3000 (if :port not set)

;; Environment variables are automatically normalized
;; DATABASE_URL, database.url, and database-url all become :database-url
(env :database-url)
```

**Key benefits:**
- Simple map-based interface
- Multiple configuration sources with priority order
- Automatic key normalization (underscores, dots, case)
- Works with Leiningen and Boot
- No external dependencies
- 12 Factor App compatible

## Core Concepts

### Configuration Sources (Priority Order)

Environ checks sources in this order (first match wins):

1. **`.lein-env` file** - Generated by lein-environ plugin (dev/test only)
2. **`.boot-env` file** - Generated by boot-environ task (dev/test only)
3. **Environment variables** - `$DATABASE_URL`
4. **Java system properties** - `-Ddatabase.url=...`

**Important:** `.lein-env` and `.boot-env` files are NOT included in uberjars. Production deployments must use environment variables or system properties.

### Key Normalization

Environ automatically normalizes keys:

```clojure
;; All of these become :database-url
;; Environment variable: DATABASE_URL
;; System property: database.url
;; Lein profile: :database-url

(env :database-url)
;; Checks DATABASE_URL, database.url, and :database-url
```

**Rules:**
- Lowercase everything
- Replace `_` and `.` with `-`
- Keywords are dash-separated

### The env Map

The `environ.core/env` var is a simple Clojure map:

```clojure
(type env)
;; => clojure.lang.PersistentHashMap

;; Access like any map
(get env :database-url)
(:database-url env)
(env :database-url)

;; With defaults
(get env :port 8080)
```

## Common Workflows

### Workflow 1: Development Setup with Leiningen

Add environ to your `project.clj`:

```clojure
;; project.clj
(defproject myapp "0.1.0"
  :dependencies [[org.clojure/clojure "1.11.1"]
                 [environ "1.2.0"]]
  :plugins [[lein-environ "1.2.0"]]
  
  :profiles
  {:dev  {:env {:database-url "jdbc:postgresql://localhost/dev"
                :debug true}}
   :test {:env {:database-url "jdbc:postgresql://localhost/test"
                :debug false}}})
```

Use in your code:

```clojure
(ns myapp.config
  (:require [environ.core :refer [env]]))

(def config
  {:database-url (env :database-url)
   :debug?       (Boolean/parseBoolean (str (env :debug)))
   :port         (Integer/parseInt (str (or (env :port) "8080")))})
```

Run with different profiles:

```bash
# Development (uses :dev profile)
lein repl

# Testing (uses :test profile)
lein test

# Production (no profile, uses env vars)
java -jar target/myapp-standalone.jar
```

### Workflow 2: Local Development with profiles.clj

Keep sensitive config out of version control:

```clojure
;; profiles.clj (git-ignored)
{:dev  {:env {:database-url "jdbc:postgresql://localhost/dev"
              :api-key "dev-key-12345"
              :secret "local-dev-secret"}}
 :test {:env {:database-url "jdbc:postgresql://localhost/test"
              :api-key "test-key-67890"}}}
```

**Best practice:** Use composite profiles in `project.clj`:

```clojure
;; project.clj
:profiles {:dev [:project/dev :profiles/dev]
           :test [:project/test :profiles/test]
           
           ;; Edit these in profiles.clj
           :profiles/dev  {}
           :profiles/test {}
           
           ;; Keep non-sensitive config here
           :project/dev {:source-paths ["dev"]
                         :dependencies [[org.clojure/tools.namespace "1.3.0"]]}
           :project/test {}}
```

### Workflow 3: Boot Build Pipeline

Add environ to your Boot pipeline:

```clojure
;; build.boot
(set-env!
  :dependencies '[[environ "1.2.0"]
                  [boot-environ "1.2.0"]])

(require '[environ.boot :refer [environ]])

;; Set environment in pipeline
(deftask dev []
  (comp
    (environ :env {:database-url "jdbc:postgresql://localhost/dev"
                   :debug true})
    (repl)))

(deftask test []
  (comp
    (environ :env {:database-url "jdbc:postgresql://localhost/test"
                   :debug false})
    (testing)))
```

Command line usage:

```bash
# Pass env vars directly
boot environ -e database-url=jdbc:postgresql://localhost/dev repl

# Or use defined tasks
boot dev
boot test
```

The `environ` task creates a `.boot-env` file in the fileset for tasks that create their own pods (like boot-test).

### Workflow 4: Production Deployment

Use environment variables in production:

```bash
# Set environment variables
export DATABASE_URL="jdbc:postgresql://prod-server/mydb"
export API_KEY="prod-key-xyz"
export PORT="8080"

# Run uberjar
java -jar myapp-standalone.jar
```

Or use Java system properties:

```bash
java -Ddatabase.url="jdbc:postgresql://prod-server/mydb" \
     -Dapi.key="prod-key-xyz" \
     -Dport=8080 \
     -jar myapp-standalone.jar
```

**Mix both:**

```bash
# Env vars take priority over system properties
export DATABASE_URL="jdbc:postgresql://prod-server/mydb"
java -Dport=8080 -jar myapp-standalone.jar
```

### Workflow 5: Using Project Map Values

Reference Leiningen project values:

```clojure
;; project.clj
(defproject myapp "1.2.3"
  :description "My application"
  
  :profiles
  {:dev {:env {:app-version :project/version
               :app-name :project/name
               :app-description :project/description}}})
```

Access in code:

```clojure
(env :app-version)
;; => "1.2.3"

(env :app-name)
;; => "myapp"

(env :app-description)
;; => "My application"
```

View the full project map: `lein pprint`

### Workflow 6: Type Coercion

Environ values are always strings. Coerce as needed:

```clojure
(ns myapp.config
  (:require [environ.core :refer [env]]))

(defn parse-int [s default]
  (try
    (Integer/parseInt (str s))
    (catch Exception _
      default)))

(defn parse-bool [s default]
  (case (str s)
    ("true" "yes" "1") true
    ("false" "no" "0") false
    default))

(def config
  {:port        (parse-int (env :port) 8080)
   :debug?      (parse-bool (env :debug) false)
   :workers     (parse-int (env :workers) 4)
   :timeout-ms  (parse-int (env :timeout-ms) 5000)})
```

**Pattern for required values:**

```clojure
(defn required [key]
  (or (env key)
      (throw (ex-info (str "Missing required config: " key)
                      {:key key}))))

(def config
  {:database-url (required :database-url)
   :api-key      (required :api-key)
   :port         (parse-int (env :port) 8080)}) ; Optional with default
```

### Workflow 7: Testing with Different Environments

Override environment in tests:

```clojure
(ns myapp.config-test
  (:require [clojure.test :refer [deftest is testing]]
            [environ.core :refer [env]]))

(deftest config-test
  (testing "uses test database"
    ;; Test profile sets :database-url
    (is (= "jdbc:postgresql://localhost/test"
           (env :database-url))))
  
  (testing "defaults work"
    (is (= 8080 (Integer/parseInt (str (or (env :port) "8080")))))))
```

Or use `with-redefs`:

```clojure
(deftest config-override-test
  (with-redefs [env (assoc env :port "9000")]
    (is (= "9000" (env :port)))))
```

## When to Use Environ

**Use Environ when:**
- Building 12 Factor Apps
- Need simple environment variable access
- Want automatic key normalization
- Using Leiningen or Boot
- Prefer minimal dependencies
- Config needs are straightforward

**Use alternatives when:**
- Need complex configuration merging (use [aero](https://github.com/juxt/aero))
- Want configuration provenance tracking (use [lambdaisland/config](/skills/libraries/configuration/lambdaisland_config.md))
- Need validation and transformation (use [cprop](https://github.com/tolitius/cprop))
- Require secret management integration
- Want type coercion built-in

**Environ vs lambdaisland/config:**
- **Environ**: Simpler, just a map, no provenance, manual type conversion
- **lambdaisland/config**: More features, tracks sources, Aero support, more structure

## Best Practices

**DO:**
- Use `profiles.clj` for local development secrets (git-ignore it)
- Set production config via environment variables or system properties
- Provide sensible defaults with `or`
- Validate required config at startup
- Use composite profiles (`:profiles/dev`) for flexibility
- Document required environment variables in README
- Use string coercion (`str`) before parsing to handle nils

**DON'T:**
- Commit sensitive values to version control
- Rely on `.lein-env` in production (it's not in uberjars)
- Forget to normalize keys when setting env vars
- Skip validation of required config
- Mix configuration and business logic
- Use environ values directly without type checking
- Assume all values are present (use defaults or validation)

## Common Issues

### Issue: Config Works in REPL but Not in Uberjar

**Problem:** Config from `project.clj` :env works in development but not production.

```clojure
;; Works: lein repl
;; Fails: java -jar target/myapp-standalone.jar
(env :database-url) ;; => nil
```

**Solution:** `.lein-env` is not included in uberjars. Use environment variables:

```bash
# Set environment variable
export DATABASE_URL="jdbc:postgresql://prod/mydb"

# Or system property
java -Ddatabase.url="jdbc:postgresql://prod/mydb" -jar myapp-standalone.jar
```

### Issue: Key Normalization Confusion

**Problem:** Environment variable not accessible with expected key.

```bash
export MY_APP_DATABASE_URL="jdbc:..."
```

```clojure
(env :my-app-database-url) ;; => nil (wrong)
```

**Solution:** Environ normalizes to lowercase with dashes:

```clojure
(env :my-app-database-url) ;; Wrong
(env :my-database-url)     ;; Wrong
(env :database-url)        ;; Correct (drops prefix if not used)
```

Better: Set the variable to match the expected key:

```bash
export DATABASE_URL="jdbc:..."
```

```clojure
(env :database-url) ;; Works
```

### Issue: Boolean Values are Strings

**Problem:** Boolean environment variables don't work as expected.

```bash
export DEBUG="true"
```

```clojure
(if (env :debug)  ; Always truthy (it's a string "true")
  (println "Debug mode"))
```

**Solution:** Parse strings to booleans:

```clojure
(defn parse-bool [s]
  (case s
    ("true" "yes" "1") true
    ("false" "no" "0") false
    nil))

(def debug? (parse-bool (env :debug)))

(if debug?
  (println "Debug mode"))
```

### Issue: Integer Parsing Errors

**Problem:** Parsing integers throws exceptions on nil or invalid input.

```clojure
(Integer/parseInt (env :port)) ; NPE if nil
```

**Solution:** Handle nil and provide defaults:

```clojure
(defn parse-int [s default]
  (try
    (Integer/parseInt (str s))
    (catch Exception _
      default)))

(def port (parse-int (env :port) 8080))
```

### Issue: profiles.clj Not Being Read

**Problem:** Local config in `profiles.clj` not working.

**Solution:** Check file location and format:

```clojure
;; Must be in project root: ./profiles.clj
;; Must be valid EDN/Clojure map
{:dev  {:env {:key "value"}}
 :test {:env {:key "test-value"}}}
```

**Check if it's being loaded:**

```bash
# See merged project map
lein pprint

# Look for your :env values under :dev or active profile
```

## Advanced Topics

### Environment Namespacing

Prefix environment variables for app-specific isolation:

```bash
# Without prefix (might conflict with system vars)
export DATABASE_URL="..."
export PORT="..."

# With prefix (app-specific)
export MYAPP_DATABASE_URL="..."
export MYAPP_PORT="..."
```

Access in code:

```clojure
;; Strip prefix in config namespace
(ns myapp.config
  (:require [environ.core :refer [env]]))

(def config
  {:database-url (env :myapp-database-url)
   :port         (env :myapp-port)})
```

Or use a helper:

```clojure
(defn prefixed-env [prefix key]
  (env (keyword (str prefix "-" (name key)))))

(def config
  {:database-url (prefixed-env "myapp" :database-url)
   :port         (prefixed-env "myapp" :port)})
```

### Testing with Fixed Environments

Use `binding` to override environ in tests:

```clojure
(ns myapp.config-test
  (:require [clojure.test :refer [deftest is]]
            [environ.core :as environ]))

(deftest with-test-env
  (with-redefs [environ/env {:database-url "test-db"
                              :port "9000"}]
    (is (= "test-db" (environ/env :database-url)))
    (is (= "9000" (environ/env :port)))))
```

### Multiple Environments Pattern

Structure config to handle multiple environments:

```clojure
(ns myapp.config
  (:require [environ.core :refer [env]]))

(def environment
  (keyword (or (env :environment) "dev")))

(def environments
  {:dev  {:database-url "jdbc:postgresql://localhost/dev"
          :log-level :debug}
   :test {:database-url "jdbc:postgresql://localhost/test"
          :log-level :info}
   :prod {:database-url (env :database-url)
          :log-level :warn}})

(def config
  (merge (get environments environment)
         ;; Override with any explicit env vars
         (when (env :database-url)
           {:database-url (env :database-url)})))
```

## Resources

**Official:**
- [GitHub Repository](https://github.com/weavejester/environ) - Source code and README
- [cljdoc](https://cljdoc.org/d/environ/environ/1.2.0) - API documentation
- [12 Factor App](http://12factor.net/) - Design principles

**Related Libraries:**
- [aero](https://github.com/juxt/aero) - Configuration with reader literals
- [lambdaisland/config](/skills/libraries/configuration/lambdaisland_config.md) - Config with provenance
- [cprop](https://github.com/tolitius/cprop) - Type-safe configuration

## Summary

Environ provides a simple, map-based interface for environment configuration:

1. **Single source of truth** - `environ.core/env` map
2. **Multiple sources** - `.lein-env`, `.boot-env`, env vars, system properties
3. **Automatic normalization** - Keys converted to lowercase dash-separated keywords
4. **12 Factor compliant** - Designed for environment-based configuration
5. **Build tool integration** - Works with Leiningen and Boot
6. **Production-ready** - Env vars and system properties in deployed artifacts

**Core pattern:**

```clojure
(require '[environ.core :refer [env]])

;; Simple access
(env :database-url)

;; With defaults
(or (env :port) 8080)

;; Required config
(or (env :api-key)
    (throw (ex-info "Missing API_KEY" {})))
```

Use Environ when you need straightforward environment variable access. Consider more feature-rich alternatives like lambdaisland/config for complex configuration needs.
