{:deps {medley/medley
        {:mvn/version "1.3.0"}
        io.github.paintparty/bling
        {:mvn/version "0.6.0"}
        clj-commons/clj-yaml
        {:mvn/version "1.0.29"}
        org.clj-commons/pretty
        {:mvn/version "3.1.0"}}

 :paths ["src" "test"]

 :tasks
 {:requires ([babashka.fs :as fs]
             [bling.core :as bling]
             [babashka.process :as p]
             [clj-yaml.core :as yaml]
             [clojure.string :as str]
             [clj-commons.format.table :as table])

  :init (do
          ;; Shared utility functions
          (defn info-msg [msg]
            (bling/callout {:type :info} (bling/bling [:bold msg])))

          (defn success-msg [msg]
            (bling/callout {:type :success} (bling/bling [:bold msg])))

          (defn warning-msg [msg]
            (bling/callout {:type :warning} (bling/bling [:bold msg])))

          (defn error-msg [msg]
            (bling/callout {:type :error} (bling/bling [:bold msg])))

          (defn require-arg [arg-name]
            (or (first *command-line-args*)
                (throw (ex-info (str "Usage: bb <task> <" arg-name ">") {}))))

          (defn get-ratio-arg []
            (let [args *command-line-args*
                  ratio-idx (first (keep-indexed
                                    (fn [idx arg] (when (= "--ratio" arg) idx))
                                    args))
                  ratio-arg (when ratio-idx (nth args (inc ratio-idx) nil))]
              (if ratio-arg (parse-double ratio-arg) 2.0)))

          (defn estimate-tokens [text]
            (Math/ceil (/ (count text) 4.0)))

          (defn format-number [n]
            (let [s (str (long n))
                  digits (reverse s)
                  parts (partition-all 3 digits)
                  formatted-parts (map (fn [part] (apply str (reverse part))) parts)]
              (str/join "," (reverse formatted-parts))))

          (defn format-size [bytes]
            (cond
              (< bytes 1024) (str bytes "B")
              (< bytes (* 1024 1024)) (str (format "%.1f" (/ bytes 1024.0)) "KB")
              :else (str (format "%.1f" (/ bytes 1024.0 1024.0)) "MB")))

          (defn extract-frontmatter [file-path]
            (let [content (slurp file-path)
                  lines (str/split-lines content)]
              (when (= "---" (first lines))
                (let [find-end (fn [lines]
                                 (first (keep-indexed
                                         (fn [idx line]
                                           (when (and (> idx 0)
                                                      (= "---" line))
                                             idx))
                                         lines)))
                      end-idx (find-end lines)]
                  (when end-idx
                    (yaml/parse-string
                     (str/join "\n" (take (dec end-idx) (drop 1 lines)))))))))

          (defn extract-metadata-with-pandoc [file-path]
            (try
              (let [result (p/shell {:out :string
                                     :err :string
                                     :continue true}
                                    (str "pandoc --template prompt_configs/metadata.plain " file-path))]
                (if (zero? (:exit result))
                  (let [json-str (str/trim (:out result))]
                    (when (and (not (str/blank? json-str))
                               (not= "{}" json-str))
                      (yaml/parse-string json-str)))
                  nil))
              (catch Exception e
                nil)))

          (defn strip-html-tags [html-str]
            (when html-str
              (-> html-str
                  (str/replace (re-pattern "<[^>]+>") "")
                  (str/replace (re-pattern "&[^;]+;") " ")
                  (str/trim))))

          (defn truncate-string [s max-length]
            (if (and s (> (count s) max-length))
              (str (subs s 0 (- max-length 3)) "...")
              (or s "")))

          (defn strip-ansi [s]
            "Remove ANSI color codes from string"
            (str/replace s (re-pattern "\033\\[[0-9;]*m") "")))

  ;; Clean all build artifacts and temporary files
  clean
  {:doc "Clean all build artifacts and temporary files"
   :task (do
           (info-msg "Cleaning build artifacts...")

           (when (fs/exists? "_build")
             (fs/delete-tree "_build"))
           (when (fs/exists? "target")
             (fs/delete-tree "target"))
           (fs/delete-if-exists "test-db.db")
           (fs/delete-if-exists "junit.xml")
           (fs/delete-if-exists "docs.html")

           (success-msg "Clean complete"))}

  test
  {:doc "Run tests with Kaocha"
   :task (do
           (info-msg "Running tests...")
           (let [start (System/currentTimeMillis)
                 result (apply clojure (into ["-M:jvm-base:dev:test"] *command-line-args*))
                 elapsed (- (System/currentTimeMillis) start)]
             (if (zero? (:exit result))
               (success-msg (format "Tests passed in %.2fs" (/ elapsed 1000.0)))
               (do
                 (error-msg "Tests failed")
                 (System/exit 1)))))}

  lint
  {:doc "Lint the code base with clj-kondo"
   :task (do
           (info-msg "Running lint task...")
           (let [start (System/currentTimeMillis)
                 result (apply clojure {:continue true}
                               ["-M:lint -m clj-kondo.main --lint dev src test"])
                 elapsed (- (System/currentTimeMillis) start)]
             (if (zero? (:exit result))
               (success-msg (format "Lint passed in %.2fs" (/ elapsed 1000.0)))
               (do
                 (error-msg "Lint failed")
                 (System/exit 1)))))}

  main
  {:doc "Run the main command line interface"
   :task (do
           (apply clojure (into ["-M:jvm-base:main"] *command-line-args*)))}

  compile
  {:doc "Compile main Clojure namespace to generate classes"
   :task (do
           (info-msg "Compiling clojure-skills.main...")
           (fs/create-dirs "classes")
           (let [result (clojure {:continue true}
                                 "-M"
                                 "-e" "(compile 'clojure-skills.main)")]
             (if (zero? (:exit result))
               (success-msg "Compilation complete")
               (do
                 (error-msg "Compilation failed")
                 (System/exit 1)))))}

  build-uberjar
  {:doc "Build uberjar (requires compile first)"
   :task (do
           (info-msg "Building uberjar...")
           (fs/create-dirs "target")
           (let [start (System/currentTimeMillis)
                 result (clojure {:continue true}
                                 "-M:jvm-base:uberdeps"
                                 "--main-class" "clojure_skills.main")]
             (if (zero? (:exit result))
               (let [elapsed (- (System/currentTimeMillis) start)]
                 (success-msg (format "Uberjar built in %.2fs: target/clojure-skills.jar"
                                      (/ elapsed 1000.0)))
                 (println)
                 (println "To run via JVM: java -jar target/clojure-skills.jar <command>")
                 (println "To build native: bb native"))
               (do
                 (error-msg "Uberjar build failed")
                 (System/exit 1)))))}

  native
  {:doc "Build native binary with GraalVM (requires GraalVM with native-image)"
   :task (do
           (info-msg "Building native binary with GraalVM...")

           ;; Check for native-image
           (let [check-result (shell {:continue true :out :string} "which native-image")]
             (when-not (zero? (:exit check-result))
               (error-msg "native-image not found!")
               (println)
               (println "Install GraalVM with native-image:")
               (println "  1. Install GraalVM: sdk install java 25.0.1-graal")
               (println "  2. Use it: sdk use java 25.0.1-graal")
               (println "  3. Install native-image: gu install native-image")
               (System/exit 1)))

           ;; Build native image
           (info-msg "Compiling native image (this may take several minutes)...")
           (let [start (System/currentTimeMillis)
                 result (apply shell {:continue true}
                               ["native-image"
                                "--no-fallback"
                                "--initialize-at-build-time"
                                "--enable-native-access=ALL-UNNAMED"
                                "-jar" "target/clojure-skills.jar"
                                "-H:Name=target/clojure-skills"])]
             (if (zero? (:exit result))
               (let [elapsed (- (System/currentTimeMillis) start)]
                 (success-msg (format "Native binary built in %.2fs: target/clojure-skills"
                                      (/ elapsed 1000.0)))
                 (println)
                 (println "Test the binary:")
                 (println "  ./target/clojure-skills stats"))
               (do
                 (error-msg "Native compilation failed")
                 (System/exit 1)))))}

  build-cli
  {:doc "Complete build: compile -> uberjar -> native binary"
   :task (do
           (run 'clean)
           (run 'compile)
           (run 'build-uberjar)
           (run 'native)
           (success-msg "Build complete! Native binary at: target/clojure-skills"))}

  outdated
  {:doc "Check for outdated dependencies"
   :task (do
           (info-msg "Checking for outdated dependencies...")
           (clojure "-M:dev:outdated -m depot.outdated.main"))}

  nrepl
  {:doc "Start nREPL server on port 7889"
   :task (do
           (info-msg "Starting nREPL server on port 7889...")
           (clojure "-M:jvm-base:dev:nrepl"))}

  fmt
  {:doc "Format Clojure code with cljstyle"
   :task (do
           (info-msg "Formatting code...")
           (clojure "-M:dev:format -m cljstyle.main fix scripts src dev")
           (success-msg "Code formatted"))}

  fmt-check
  {:doc "Check Clojure code formatting"
   :task (do
           (info-msg "Checking code formatting...")
           (let [result (clojure {:continue true} "-M:dev:format -m cljstyle.main check scripts src dev")]
             (if (zero? (:exit result))
               (success-msg "Format check passed")
               (do
                 (error-msg "Format check failed - run 'bb fmt' to fix")
                 (System/exit 1)))))}

  typos
  {:doc "Check for typos in the codebase"
   :task (do
           (info-msg "Checking for typos...")
           (let [result (shell {:continue true} "typos")]
             (if (zero? (:exit result))
               (success-msg "No typos found")
               (do
                 (error-msg "Typos found - run 'bb typos-fix' to fix")
                 (System/exit 1)))))}

  typos-fix
  {:doc "Automatically fix typos in the codebase"
   :task (do
           (info-msg "Fixing typos...")
           (shell "typos --write-changes")
           (success-msg "Typos fixed"))}

  ci
  {:doc "Run full CI pipeline: clean, format check, lint, typos, test"
   :task (do
           (run 'clean)
           (run 'fmt-check)
           (run 'lint)
           ;; Disable typos in the CI for now
           ;; (run 'typos)
           (run 'test)
           (success-msg "CI pipeline completed successfully"))}

  migrate
  {:doc "Run database migrations"
   :task (do
           (info-msg "Running database migrations...")
           (shell "clojure -M:jvm-base:migrate migrate"))}

  rollback
  {:doc "Rollback database migrations\nUsage: bb rollback [n] - rollback last n migrations (default: 1)"
   :task (let [amount (or (first *command-line-args*) "1")]
           (info-msg (str "Rolling back " amount " migration(s)..."))
           (shell (str "clojure -M:jvm-base:migrate rollback " amount)))}

  rollback-all
  {:doc "Rollback all database migrations"
   :task (do
           (warning-msg "WARNING: This will rollback ALL migrations!")
           (info-msg "Rolling back all migrations...")
           (shell "clojure -M:jvm-base:migrate rollback-all"))}}}
