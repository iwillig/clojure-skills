{:deps {medley/medley
        {:mvn/version "1.3.0"}
        io.github.paintparty/bling
        {:mvn/version "0.6.0"}
        clj-commons/clj-yaml
        {:mvn/version "1.0.29"}
        org.clj-commons/pretty
        {:mvn/version "3.1.0"}}

 :paths ["src" "test"]

 :tasks
 {:requires ([babashka.fs :as fs]
             [bling.core :as bling]
             [babashka.process :as p]
             [clj-yaml.core :as yaml]
             [clojure.string :as str]
             [clj-commons.format.table :as table])

  :init (do
          ;; Shared utility functions
          (defn info-msg [msg]
            (bling/callout {:type :info} (bling/bling [:bold msg])))

          (defn success-msg [msg]
            (bling/callout {:type :success} (bling/bling [:bold msg])))

          (defn warning-msg [msg]
            (bling/callout {:type :warning} (bling/bling [:bold msg])))

          (defn error-msg [msg]
            (bling/callout {:type :error} (bling/bling [:bold msg])))

          (defn require-arg [arg-name]
            (or (first *command-line-args*)
                (throw (ex-info (str "Usage: bb <task> <" arg-name ">") {}))))

          (defn get-ratio-arg []
            (let [args *command-line-args*
                  ratio-idx (first (keep-indexed
                                    (fn [idx arg] (when (= "--ratio" arg) idx))
                                    args))
                  ratio-arg (when ratio-idx (nth args (inc ratio-idx) nil))]
              (if ratio-arg (parse-double ratio-arg) 10.0)))

          (defn estimate-tokens [text]
            (Math/ceil (/ (count text) 4.0)))

          (defn format-number [n]
            (let [s (str (long n))
                  digits (reverse s)
                  parts (partition-all 3 digits)
                  formatted-parts (map (fn [part] (apply str (reverse part))) parts)]
              (str/join "," (reverse formatted-parts))))

          (defn format-size [bytes]
            (cond
              (< bytes 1024) (str bytes "B")
              (< bytes (* 1024 1024)) (str (format "%.1f" (/ bytes 1024.0)) "KB")
              :else (str (format "%.1f" (/ bytes 1024.0 1024.0)) "MB")))

          (defn extract-frontmatter [file-path]
            (let [content (slurp file-path)
                  lines (str/split-lines content)]
              (when (= "---" (first lines))
                (let [find-end (fn [lines]
                                 (first (keep-indexed
                                         (fn [idx line]
                                           (when (and (> idx 0)
                                                      (= "---" line))
                                             idx))
                                         lines)))
                      end-idx (find-end lines)]
                  (when end-idx
                    (yaml/parse-string
                     (str/join "\n" (take (dec end-idx) (drop 1 lines))))))))))

  ;; Build a specific prompt file by name
  build
  {:doc "Build a specific prompt file by name (without .md extension)\nUsage: bb build clojure_skill_builder"
   :task (let [name (require-arg "name")
               prompt-file (str "prompts/" name ".md")
               metadata-file (str "prompt_templates/" name ".yaml")
               output-file (str "_build/" name ".md")
               template-file "prompt_templates/combine.md"]

           ;; Validate all required files exist
           (when-not (fs/exists? prompt-file)
             (error-msg (str "Prompt file not found: " prompt-file))
             (System/exit 1))

           (when-not (fs/exists? metadata-file)
             (error-msg (str "Metadata file not found: " metadata-file))
             (System/exit 1))

           (when-not (fs/exists? template-file)
             (error-msg (str "Template file not found: " template-file))
             (System/exit 1))

           (info-msg (str "Building " output-file "..."))
           (fs/create-dirs "_build")

           ;; Read and validate skills
           (let [meta-content (yaml/parse-string (slurp metadata-file))
                 skills (get meta-content :skills [])
                 missing-skills (filter (fn [s] (not (fs/exists? s))) skills)]

             (when (seq missing-skills)
               (error-msg "Missing skill files:")
               (doseq [skill missing-skills]
                 (println "  -" skill))
               (System/exit 1))

             (let [skill-files (str/join " " skills)
                   pandoc-cmd (str "pandoc " prompt-file " " skill-files
                                   " --metadata-file=" metadata-file
                                   " --template=" template-file
                                   " -o " output-file)]

               (shell pandoc-cmd)
               (success-msg (str "Build successful: " output-file)))))}

  ;; Build all prompt files
  build-all
  {:doc "Build all prompt files"
   :task (do
           (info-msg "Building all prompts...")

           ;; Build clojure_skill_builder
           (shell "bb build clojure_skill_builder")

           ;; Build clojure_build
           (shell "bb build clojure_build")
           (shell "bb build shortcut_cli_builder")

           (success-msg "All builds complete!"))}

  ;; List built prompts with token counts
  list-prompts
  {:doc "List all built prompts with file sizes and token counts"
   :task (let [build-dir "_build"]

           (if-not (fs/exists? build-dir)
             (do
               (warning-msg "No _build directory found. Run 'bb build-all' first.")
               (System/exit 1))

             (let [prompt-files (sort (filter (fn [f]
                                                (str/ends-with? (str f) ".md"))
                                              (fs/list-dir build-dir)))

                   ;; Collect data for each prompt
                   prompts (for [file prompt-files]
                             (let [file-path (str file)
                                   content (slurp file-path)
                                   file-size (fs/size file)
                                   char-count (count content)
                                   token-count (estimate-tokens content)
                                   filename (fs/file-name file)]
                               {:name (str/replace filename ".md" "")
                                :file file-path
                                :size file-size
                                :size-str (format-size file-size)
                                :chars char-count
                                :tokens (long token-count)}))

                   ;; Calculate totals
                   total-size (reduce + (map :size prompts))
                   total-chars (reduce + (map :chars prompts))
                   total-tokens (reduce + (map :tokens prompts))]

               (info-msg "Built Prompts")

               (println)
               (table/print-table [:name :size :chars :tokens]
                                  (concat
                                   (for [p prompts]
                                     {:name (:name p)
                                      :size (:size-str p)
                                      :chars (format-number (:chars p))
                                      :tokens (format-number (:tokens p))})
                                   [{:name "TOTAL"
                                     :size (format-size total-size)
                                     :chars (format-number total-chars)
                                     :tokens (format-number total-tokens)}]))

               (println)
               (println (bling/bling [:dim "Note: Token count is estimated (~4 chars per token)"]))
               (println (bling/bling [:dim "      Anthropic's Claude models use this approximation."])))))}

  ;; Clean all build artifacts and temporary files
  clean
  {:doc "Clean all build artifacts and temporary files"
   :task (do
           (info-msg "Cleaning build artifacts...")

           (when (fs/exists? "_build")
             (fs/delete-tree "_build"))
           (when (fs/exists? "target")
             (fs/delete-tree "target"))
           (fs/delete-if-exists "test-db.db")
           (fs/delete-if-exists "junit.xml")
           (fs/delete-if-exists "docs.html")

           (success-msg "Clean complete"))}

  test
  {:doc "Run tests with Kaocha"
   :task (do
           (info-msg "Running tests...")
           (let [start (System/currentTimeMillis)
                 result (clojure {:continue true} "-M:jvm-base:dev:test")
                 elapsed (- (System/currentTimeMillis) start)]
             (if (zero? (:exit result))
               (success-msg (format "Tests passed in %.2fs" (/ elapsed 1000.0)))
               (do
                 (error-msg "Tests failed")
                 (System/exit 1)))))}

  lint
  {:doc "Lint the code base with clj-kondo"
   :task (do
           (info-msg "Running lint task...")
           (let [start (System/currentTimeMillis)
                 result (clojure {:continue true} "-M:lint -m clj-kondo.main --lint dev src test")
                 elapsed (- (System/currentTimeMillis) start)]
             (if (zero? (:exit result))
               (success-msg (format "Lint passed in %.2fs" (/ elapsed 1000.0)))
               (do
                 (error-msg "Lint failed")
                 (System/exit 1)))))}

  main
  {:doc "Run the main command line interface"
   :task (do
           (apply clojure (into ["-M:jvm-base:main"] *command-line-args*)))}

  outdated
  {:doc "Check for outdated dependencies"
   :task (do
           (info-msg "Checking for outdated dependencies...")
           (clojure "-M:dev:outdated -m depot.outdated.main"))}

  nrepl
  {:doc "Start nREPL server on port 7889"
   :task (do
           (info-msg "Starting nREPL server on port 7889...")
           (clojure "-M:jvm-base:dev:nrepl"))}

  fmt
  {:doc "Format Clojure code with cljstyle"
   :task (do
           (info-msg "Formatting code...")
           (clojure "-M:dev:format -m cljstyle.main fix scripts src dev")
           (success-msg "Code formatted"))}

  fmt-check
  {:doc "Check Clojure code formatting"
   :task (do
           (info-msg "Checking code formatting...")
           (let [result (clojure {:continue true} "-M:dev:format -m cljstyle.main check scripts src dev")]
             (if (zero? (:exit result))
               (success-msg "Format check passed")
               (do
                 (error-msg "Format check failed - run 'bb fmt' to fix")
                 (System/exit 1)))))}

  typos
  {:doc "Check for typos in the codebase"
   :task (do
           (info-msg "Checking for typos...")
           (let [result (shell {:continue true} "typos")]
             (if (zero? (:exit result))
               (success-msg "No typos found")
               (do
                 (error-msg "Typos found - run 'bb typos-fix' to fix")
                 (System/exit 1)))))}

  typos-fix
  {:doc "Automatically fix typos in the codebase"
   :task (do
           (info-msg "Fixing typos...")
           (shell "typos --write-changes")
           (success-msg "Typos fixed"))}

  ci
  {:doc "Run full CI pipeline: clean, format check, lint, typos, test"
   :task (do
           (run 'clean)
           (run 'fmt-check)
           (run 'lint)
           (run 'typos)
           (run 'test)
           (success-msg "CI pipeline completed successfully"))}

  list-skills
  {:doc "List all skills with metadata in a table format"
   :task (let [skills-dir "skills"
               skill-files (sort (map str (fs/glob skills-dir "**/*.md")))

               ;; Parse all skills
               skills (for [file-path skill-files]
                        (let [metadata (extract-frontmatter file-path)
                              file-size (fs/size file-path)
                              content (slurp file-path)
                              char-count (count content)
                              token-count (long (estimate-tokens content))
                              relative-path (str/replace file-path
                                                         (str (fs/file skills-dir) "/")
                                                         "")
                              category (first (str/split relative-path (re-pattern "/")))]
                          {:category category
                           :name (get metadata :name "unknown")
                           :path relative-path
                           :size (format-size file-size)
                           :tokens (format-number token-count)
                           :description (get metadata :description "")}))

               ;; Calculate totals
               total-size (reduce + (map (fn [s] (fs/size (str "skills/" (:path s)))) skills))
               total-tokens (reduce + (map (fn [s] (long (estimate-tokens (slurp (str "skills/" (:path s)))))) skills))]

           (info-msg "Available Skills")

           (println)
           (table/print-table [:category :name :path :size :tokens]
                              (concat
                               (sort-by (juxt :category :name) skills)
                               [{:category "TOTAL"
                                 :name (str (count skills) " skills")
                                 :path ""
                                 :size (format-size total-size)
                                 :tokens (format-number total-tokens)}]))

           (println)
           (println (bling/bling [:dim "Note: Token count is estimated (~4 chars per token)"])))}

  watch
  {:doc "Watch for changes and rebuild prompts automatically\nUsage: bb watch [prompt-name]"
   :task (let [name (first *command-line-args*)]
           (info-msg (if name
                       (str "Watching for changes to rebuild " name "...")
                       "Watching for changes to rebuild all prompts..."))

           ;; Use babashka.fs/watch
           (let [watch-paths ["prompts" "skills" "prompt_templates"]]
             (apply fs/watch
                    (for [path watch-paths
                          :when (fs/exists? path)]
                      path)
                    (fn [{:keys [type path]}]
                      (when (and (= :modify type)
                                 (str/ends-with? (str path) ".md"))
                        (info-msg (str "Change detected: " path))
                        (try
                          (if name
                            (shell (str "bb build " name))
                            (shell "bb build-all"))
                          (catch Exception e
                            (error-msg (str "Build failed: " (.getMessage e))))))))))}

  ;; LLMLingua compression tasks

  setup-python
  {:doc "Install Python dependencies using pipenv"
   :task (do
           (info-msg "Installing Python dependencies with pipenv...")

           (shell "pipenv install")

           (success-msg "Python environment ready!")

           (println)
           (println "You can now use:")
           (println "  bb compress <name> --ratio 10")
           (println "  bb build-compressed <name> --ratio 10")
           (println "  bb compress-skill skills/path/to/file.md --ratio 10"))}

  compress
  {:doc "Compress a built prompt file using LLMLingua\nUsage: bb compress clojure_skill_builder --ratio 10"
   :task (let [args *command-line-args*
               name (first args)
               ratio (get-ratio-arg)

               input (str "_build/" name ".md")
               output (str "_build/" name ".compressed.md")]

           (when-not name
             (throw (ex-info "Usage: bb compress <name> [--ratio N]" {})))

           (when-not (fs/exists? input)
             (error-msg (str "Built file not found: " input))
             (println "\nRun 'bb build " name "' first.")
             (System/exit 1))

           (info-msg (str "Compressing " input " with " ratio "x ratio..."))

           ;; Run Python compression script via pipenv
           (let [result (shell {:out :string
                                :err :string
                                :continue true}
                               (str "pipenv run python scripts/compress_prompt.py"
                                    " --input " input
                                    " --output " output
                                    " --ratio " ratio))]
             (if (zero? (:exit result))
               (do
                 (println (:out result))
                 (success-msg (str "Compression successful: " output)))
               (do
                 (println (:err result))
                 (error-msg "Compression failed")
                 (System/exit 1)))))}

  compress-skill
  {:doc "Compress a single skill file\nUsage: bb compress-skill skills/libraries/data_validation/malli.md --ratio 10"
   :task (let [args *command-line-args*
               input-file (first args)
               ratio (get-ratio-arg)

               ;; Create output path by adding .compressed before .md
               output-file (str/replace input-file (re-pattern "\\.md$") ".compressed.md")]

           (when-not input-file
             (throw (ex-info "Usage: bb compress-skill <path/to/skill.md> [--ratio N]" {})))

           (when-not (fs/exists? input-file)
             (error-msg (str "Skill file not found: " input-file))
             (System/exit 1))

           (info-msg (str "Compressing " input-file " with " ratio "x ratio..."))

           (let [result (shell {:out :string
                                :err :string
                                :continue true}
                               (str "pipenv run python scripts/compress_prompt.py"
                                    " --input " input-file
                                    " --output " output-file
                                    " --ratio " ratio))]
             (if (zero? (:exit result))
               (do
                 (println (:out result))
                 (success-msg (str "Compressed: " output-file)))
               (do
                 (println (:err result))
                 (error-msg "Compression failed")
                 (System/exit 1)))))}}}
