{:deps {medley/medley
        {:mvn/version "1.3.0"}
        io.github.paintparty/bling
        {:mvn/version "0.6.0"}
        clj-commons/clj-yaml
        {:mvn/version "1.0.29"}
        org.clj-commons/pretty
        {:mvn/version "3.1.0"}}

 :paths ["src" "test"]

 :tasks
 {:requires ([babashka.fs :as fs]
             [bling.core :as bling]
             [babashka.process :as p]
             [clj-yaml.core :as yaml]
             [clojure.string :as str]
             [clj-commons.format.table :as table])

  :init (do
          ;; Shared utility functions
          (defn info-msg [msg]
            (bling/callout {:type :info} (bling/bling [:bold msg])))

          (defn success-msg [msg]
            (bling/callout {:type :success} (bling/bling [:bold msg])))

          (defn warning-msg [msg]
            (bling/callout {:type :warning} (bling/bling [:bold msg])))

          (defn error-msg [msg]
            (bling/callout {:type :error} (bling/bling [:bold msg])))

          (defn require-arg [arg-name]
            (or (first *command-line-args*)
                (throw (ex-info (str "Usage: bb <task> <" arg-name ">") {}))))

          (defn get-ratio-arg []
            (let [args *command-line-args*
                  ratio-idx (first (keep-indexed
                                    (fn [idx arg] (when (= "--ratio" arg) idx))
                                    args))
                  ratio-arg (when ratio-idx (nth args (inc ratio-idx) nil))]
              (if ratio-arg (parse-double ratio-arg) 2.0)))

          (defn estimate-tokens [text]
            (Math/ceil (/ (count text) 4.0)))

          (defn format-number [n]
            (let [s (str (long n))
                  digits (reverse s)
                  parts (partition-all 3 digits)
                  formatted-parts (map (fn [part] (apply str (reverse part))) parts)]
              (str/join "," (reverse formatted-parts))))

          (defn format-size [bytes]
            (cond
              (< bytes 1024) (str bytes "B")
              (< bytes (* 1024 1024)) (str (format "%.1f" (/ bytes 1024.0)) "KB")
              :else (str (format "%.1f" (/ bytes 1024.0 1024.0)) "MB")))

          (defn extract-frontmatter [file-path]
            (let [content (slurp file-path)
                  lines (str/split-lines content)]
              (when (= "---" (first lines))
                (let [find-end (fn [lines]
                                 (first (keep-indexed
                                         (fn [idx line]
                                           (when (and (> idx 0)
                                                      (= "---" line))
                                             idx))
                                         lines)))
                      end-idx (find-end lines)]
                  (when end-idx
                    (yaml/parse-string
                     (str/join "\n" (take (dec end-idx) (drop 1 lines)))))))))

          (defn extract-metadata-with-pandoc [file-path]
            (try
              (let [result (p/shell {:out :string
                                     :err :string
                                     :continue true}
                                    (str "pandoc --template prompt_configs/metadata.plain " file-path))]
                (if (zero? (:exit result))
                  (let [json-str (str/trim (:out result))]
                    (when (and (not (str/blank? json-str))
                               (not= "{}" json-str))
                      (yaml/parse-string json-str)))
                  nil))
              (catch Exception e
                nil)))

          (defn strip-html-tags [html-str]
            (when html-str
              (-> html-str
                  (str/replace (re-pattern "<[^>]+>") "")
                  (str/replace (re-pattern "&[^;]+;") " ")
                  (str/trim))))

          (defn truncate-string [s max-length]
            (if (and s (> (count s) max-length))
              (str (subs s 0 (- max-length 3)) "...")
              (or s ""))))

  ;; Build a specific prompt file by name
  build
  {:doc "Build a specific prompt file by name (without .md extension)\nUsage: bb build clojure_skill_builder"
   :task (let [name (require-arg "name")
               prompt-file (str "prompts/" name ".md")
               metadata-file (str "prompt_configs/" name ".yaml")
               output-file (str "_build/" name ".md")
               template-file "prompt_configs/combine.md"]

           ;; Validate all required files exist
           (when-not (fs/exists? prompt-file)
             (error-msg (str "Prompt file not found: " prompt-file))
             (System/exit 1))

           (when-not (fs/exists? metadata-file)
             (error-msg (str "Metadata file not found: " metadata-file))
             (System/exit 1))

           (when-not (fs/exists? template-file)
             (error-msg (str "Template file not found: " template-file))
             (System/exit 1))

           (info-msg (str "Building " output-file "..."))
           (fs/create-dirs "_build")

           ;; Read and validate skills
           (let [meta-content (yaml/parse-string (slurp metadata-file))
                 skills (get meta-content :skills [])
                 missing-skills (filter (fn [s] (not (fs/exists? s))) skills)]

             (when (seq missing-skills)
               (error-msg "Missing skill files:")
               (doseq [skill missing-skills]
                 (println "  -" skill))
               (System/exit 1))

             (let [skill-files (str/join " " skills)
                   pandoc-cmd (str "pandoc " prompt-file " " skill-files
                                   " --metadata-file=" metadata-file
                                   " --template=" template-file
                                   " -o " output-file)]

               (shell pandoc-cmd)
               (success-msg (str "Build successful: " output-file)))))}

  ;; Build all prompt files
  build-all
  {:doc "Build all prompt files"
   :task (do
           (info-msg "Building all prompts...")

           ;; Build clojure_skill_builder
           (shell "bb build clojure_skill_builder")

           ;; Build clojure_build
           (shell "bb build clojure_build")
           (shell "bb build code_archivist")
           (shell "bb build plan_executor")

           (shell "bb build shortcut_cli_builder")
           (shell "bb build software_alchemist_build")

           (success-msg "All builds complete!"))}

  ;; List built prompts with token counts
  list-prompts
  {:doc "List all built prompts with file sizes and token counts"
   :task (let [build-dir "_build"]

           (if-not (fs/exists? build-dir)
             (do
               (warning-msg "No _build directory found. Run 'bb build-all' first.")
               (System/exit 1))

             (let [prompt-files (sort (filter (fn [f]
                                                (str/ends-with? (str f) ".md"))
                                              (fs/list-dir build-dir)))

;; Collect data for each prompt with metadata
                   prompts (for [file prompt-files]
                             (let [file-path (str file)
                                   filename (fs/file-name file)
                                   base-name (-> filename
                                                 (str/replace ".compressed.md" "")
                                                 (str/replace ".md" ""))
                                   source-prompt (str "prompts/" base-name ".md")
                                   metadata (if (fs/exists? source-prompt)
                                              (extract-metadata-with-pandoc source-prompt)
                                              (extract-metadata-with-pandoc file-path))
                                   content (slurp file-path)
                                   file-size (fs/size file)
                                   char-count (count content)
                                   token-count (estimate-tokens content)
                                   prompt-name (or (get metadata :name)
                                                   (get metadata :title)
                                                   base-name)
                                   description (strip-html-tags (get metadata :description ""))]
                               {:filename filename
                                :name prompt-name
                                :description description
                                :file file-path
                                :size file-size
                                :size-str (format-size file-size)
                                :chars char-count
                                :tokens (long token-count)}))

                   ;; Calculate totals
                   total-size (reduce + (map :size prompts))
                   total-chars (reduce + (map :chars prompts))
                   total-tokens (reduce + (map :tokens prompts))]

               (info-msg "Built Prompts")

               (println)
               (table/print-table [:filename :name :description :size :chars :tokens]
                                  (concat
                                   (for [p prompts]
                                     {:filename (:filename p)
                                      :name (:name p)
                                      :description (truncate-string (:description p) 60)
                                      :size (:size-str p)
                                      :chars (format-number (:chars p))
                                      :tokens (format-number (:tokens p))})
                                   [{:filename "TOTAL"
                                     :name ""
                                     :description ""
                                     :size (format-size total-size)
                                     :chars (format-number total-chars)
                                     :tokens (format-number total-tokens)}]))

               (println)
               (println (bling/bling [:dim "Note: Token count is estimated (~4 chars per token)"]))
               (println (bling/bling [:dim "      Anthropic's Claude models use this approximation."])))))}

  ;; Clean all build artifacts and temporary files
  clean
  {:doc "Clean all build artifacts and temporary files"
   :task (do
           (info-msg "Cleaning build artifacts...")

           (when (fs/exists? "_build")
             (fs/delete-tree "_build"))
           (when (fs/exists? "target")
             (fs/delete-tree "target"))
           (fs/delete-if-exists "test-db.db")
           (fs/delete-if-exists "junit.xml")
           (fs/delete-if-exists "docs.html")

           (success-msg "Clean complete"))}

  test
  {:doc "Run tests with Kaocha"
   :task (do
           (info-msg "Running tests...")
           (let [start (System/currentTimeMillis)
                 result (apply clojure (into ["-M:jvm-base:dev:test"] *command-line-args*))
                 elapsed (- (System/currentTimeMillis) start)]
             (if (zero? (:exit result))
               (success-msg (format "Tests passed in %.2fs" (/ elapsed 1000.0)))
               (do
                 (error-msg "Tests failed")
                 (System/exit 1)))))}

  lint
  {:doc "Lint the code base with clj-kondo"
   :task (do
           (info-msg "Running lint task...")
           (let [start (System/currentTimeMillis)
                 result (apply clojure {:continue true}
                               ["-M:lint -m clj-kondo.main --lint dev src test"])
                 elapsed (- (System/currentTimeMillis) start)]
             (if (zero? (:exit result))
               (success-msg (format "Lint passed in %.2fs" (/ elapsed 1000.0)))
               (do
                 (error-msg "Lint failed")
                 (System/exit 1)))))}

  main
  {:doc "Run the main command line interface"
   :task (do
           (apply clojure (into ["-M:jvm-base:main"] *command-line-args*)))}

  compile
  {:doc "Compile main Clojure namespace to generate classes"
   :task (do
           (info-msg "Compiling clojure-skills.main...")
           (fs/create-dirs "classes")
           (let [result (clojure {:continue true}
                                 "-M"
                                 "-e" "(compile 'clojure-skills.main)")]
             (if (zero? (:exit result))
               (success-msg "Compilation complete")
               (do
                 (error-msg "Compilation failed")
                 (System/exit 1)))))}

  build-uberjar
  {:doc "Build uberjar (requires compile first)"
   :task (do
           (info-msg "Building uberjar...")
           (fs/create-dirs "target")
           (let [start (System/currentTimeMillis)
                 result (clojure {:continue true}
                                 "-M:jvm-base:uberdeps"
                                 "--main-class" "clojure_skills.main")]
             (if (zero? (:exit result))
               (let [elapsed (- (System/currentTimeMillis) start)]
                 (success-msg (format "Uberjar built in %.2fs: target/clojure-skills.jar"
                                      (/ elapsed 1000.0)))
                 (println)
                 (println "To run via JVM: java -jar target/clojure-skills.jar <command>")
                 (println "To build native: bb native"))
               (do
                 (error-msg "Uberjar build failed")
                 (System/exit 1)))))}

  native
  {:doc "Build native binary with GraalVM (requires GraalVM with native-image)"
   :task (do
           (info-msg "Building native binary with GraalVM...")

           ;; Check for native-image
           (let [check-result (shell {:continue true :out :string} "which native-image")]
             (when-not (zero? (:exit check-result))
               (error-msg "native-image not found!")
               (println)
               (println "Install GraalVM with native-image:")
               (println "  1. Install GraalVM: sdk install java 25.0.1-graal")
               (println "  2. Use it: sdk use java 25.0.1-graal")
               (println "  3. Install native-image: gu install native-image")
               (System/exit 1)))

           ;; Build native image
           (info-msg "Compiling native image (this may take several minutes)...")
           (let [start (System/currentTimeMillis)
                 result (apply shell {:continue true}
                               ["native-image"
                                "--no-fallback"
                                "--initialize-at-build-time"
                                "--enable-native-access=ALL-UNNAMED"
                                "-jar" "target/clojure-skills.jar"
                                "-H:Name=target/clojure-skills"])]
             (if (zero? (:exit result))
               (let [elapsed (- (System/currentTimeMillis) start)]
                 (success-msg (format "Native binary built in %.2fs: target/clojure-skills"
                                      (/ elapsed 1000.0)))
                 (println)
                 (println "Test the binary:")
                 (println "  ./target/clojure-skills stats"))
               (do
                 (error-msg "Native compilation failed")
                 (System/exit 1)))))}

  build-cli
  {:doc "Complete build: compile -> uberjar -> native binary"
   :task (do
           (run 'clean)
           (run 'compile)
           (run 'build-uberjar)
           (run 'native)
           (success-msg "Build complete! Native binary at: target/clojure-skills"))}

  outdated
  {:doc "Check for outdated dependencies"
   :task (do
           (info-msg "Checking for outdated dependencies...")
           (clojure "-M:dev:outdated -m depot.outdated.main"))}

  nrepl
  {:doc "Start nREPL server on port 7889"
   :task (do
           (info-msg "Starting nREPL server on port 7889...")
           (clojure "-M:jvm-base:dev:nrepl"))}

  fmt
  {:doc "Format Clojure code with cljstyle"
   :task (do
           (info-msg "Formatting code...")
           (clojure "-M:dev:format -m cljstyle.main fix scripts src dev")
           (success-msg "Code formatted"))}

  fmt-check
  {:doc "Check Clojure code formatting"
   :task (do
           (info-msg "Checking code formatting...")
           (let [result (clojure {:continue true} "-M:dev:format -m cljstyle.main check scripts src dev")]
             (if (zero? (:exit result))
               (success-msg "Format check passed")
               (do
                 (error-msg "Format check failed - run 'bb fmt' to fix")
                 (System/exit 1)))))}

  typos
  {:doc "Check for typos in the codebase"
   :task (do
           (info-msg "Checking for typos...")
           (let [result (shell {:continue true} "typos")]
             (if (zero? (:exit result))
               (success-msg "No typos found")
               (do
                 (error-msg "Typos found - run 'bb typos-fix' to fix")
                 (System/exit 1)))))}

  typos-fix
  {:doc "Automatically fix typos in the codebase"
   :task (do
           (info-msg "Fixing typos...")
           (shell "typos --write-changes")
           (success-msg "Typos fixed"))}

  ci
  {:doc "Run full CI pipeline: clean, format check, lint, typos, test"
   :task (do
           (run 'clean)
           (run 'fmt-check)
           (run 'lint)
           (run 'typos)
           (run 'test)
           (success-msg "CI pipeline completed successfully"))}

  list-skills
  {:doc "List all skills with metadata in a table format"
   :task (let [skills-dir "skills"
               skill-files (sort (map str (fs/glob skills-dir "**/*.md")))

               ;; Parse all skills with pandoc metadata
               skills (for [file-path skill-files]
                        (let [metadata (extract-metadata-with-pandoc file-path)
                              file-size (fs/size file-path)
                              content (slurp file-path)
                              char-count (count content)
                              token-count (long (estimate-tokens content))
                              relative-path (str/replace file-path
                                                         (str (fs/file skills-dir) "/")
                                                         "")
                              category (first (str/split relative-path (re-pattern "/")))
                              skill-name (or (get metadata :name)
                                             (get metadata :title)
                                             (str/replace (fs/file-name file-path) ".md" ""))
                              description (strip-html-tags (get metadata :description ""))]
                          {:category category
                           :name skill-name
                           :path relative-path
                           :size (format-size file-size)
                           :tokens (format-number token-count)
                           :description description}))

               ;; Calculate totals
               total-size (reduce + (map (fn [s] (fs/size (str "skills/" (:path s)))) skills))
               total-tokens (reduce + (map (fn [s] (long (estimate-tokens (slurp (str "skills/" (:path s)))))) skills))]

           (info-msg "Available Skills")

           (println)
           (table/print-table [:category :name :description :size :tokens]
                              (concat
                               (for [s (sort-by (juxt :category :name) skills)]
                                 (assoc s :description (truncate-string (:description s) 80)))
                               [{:category "TOTAL"
                                 :name (str (count skills) " skills")
                                 :description ""
                                 :size (format-size total-size)
                                 :tokens (format-number total-tokens)}]))

           (println)
           (println (bling/bling [:dim "Note: Token count is estimated (~4 chars per token)"])))}

  watch
  {:doc "Watch for changes and rebuild prompts automatically\nUsage: bb watch [prompt-name]"
   :task (let [name (first *command-line-args*)]
           (info-msg (if name
                       (str "Watching for changes to rebuild " name "...")
                       "Watching for changes to rebuild all prompts..."))

           ;; Use babashka.fs/watch
           (let [watch-paths ["prompts" "skills" "prompt_configs"]]
             (apply fs/watch
                    (for [path watch-paths
                          :when (fs/exists? path)]
                      path)
                    (fn [{:keys [type path]}]
                      (when (and (= :modify type)
                                 (str/ends-with? (str path) ".md"))
                        (info-msg (str "Change detected: " path))
                        (try
                          (if name
                            (shell (str "bb build " name))
                            (shell "bb build-all"))
                          (catch Exception e
                            (error-msg (str "Build failed: " (.getMessage e))))))))))}

  ;; LLMLingua compression tasks

  setup-python
  {:doc "Install Python dependencies using pipenv"
   :task (do
           (info-msg "Installing Python dependencies with pipenv...")

           (shell "pipenv install")

           (success-msg "Python environment ready!")

           (println)
           (println "You can now use:")
           (println "  bb compress <name> --ratio 2")
           (println "  bb build-compressed <name> --ratio 3")
           (println "  bb compress-skill skills/path/to/file.md --ratio 2"))}

  compress
  {:doc "Compress a built prompt file using LLMLingua (default: 2x ratio)\nUsage: bb compress clojure_skill_builder [--ratio 2]"
   :task (let [args *command-line-args*
               name (first args)
               ratio (get-ratio-arg)

               input (str "_build/" name ".md")
               output (str "_build/" name ".compressed.md")]

           (when-not name
             (throw (ex-info "Usage: bb compress <name> [--ratio N]" {})))

           (when-not (fs/exists? input)
             (error-msg (str "Built file not found: " input))
             (println "\nRun 'bb build " name "' first.")
             (System/exit 1))

           (info-msg (str "Compressing " input " with " ratio "x ratio..."))

           ;; Run Python compression script via pipenv
           (let [result (shell {:out :string
                                :err :string
                                :continue true}
                               (str "pipenv run python scripts/compress_prompt.py"
                                    " --input " input
                                    " --output " output
                                    " --ratio " ratio))]
             (if (zero? (:exit result))
               (do
                 (println (:out result))
                 (success-msg (str "Compression successful: " output)))
               (do
                 (println (:err result))
                 (error-msg "Compression failed")
                 (System/exit 1)))))}

  compress-skill
  {:doc "Compress a single skill file (default: 2x ratio)\nUsage: bb compress-skill skills/libraries/data_validation/malli.md [--ratio 2]"
   :task (let [args *command-line-args*
               input-file (first args)
               ratio (get-ratio-arg)

               ;; Create output path by adding .compressed before .md
               output-file (str/replace input-file (re-pattern "\\.md$") ".compressed.md")]

           (when-not input-file
             (throw (ex-info "Usage: bb compress-skill <path/to/skill.md> [--ratio N]" {})))

           (when-not (fs/exists? input-file)
             (error-msg (str "Skill file not found: " input-file))
             (System/exit 1))

           (info-msg (str "Compressing " input-file " with " ratio "x ratio..."))

           (let [result (shell {:out :string
                                :err :string
                                :continue true}
                               (str "pipenv run python scripts/compress_prompt.py"
                                    " --input " input-file
                                    " --output " output-file
                                    " --ratio " ratio))]
             (if (zero? (:exit result))
               (do
                 (println (:out result))
                 (success-msg (str "Compressed: " output-file)))
               (do
                 (println (:err result))
                 (error-msg "Compression failed")
                 (System/exit 1)))))}

  migrate
  {:doc "Run database migrations"
   :task (do
           (info-msg "Running database migrations...")
           (shell "clojure -M:jvm-base:migrate migrate"))}

  rollback
  {:doc "Rollback database migrations\nUsage: bb rollback [n] - rollback last n migrations (default: 1)"
   :task (let [amount (or (first *command-line-args*) "1")]
           (info-msg (str "Rolling back " amount " migration(s)..."))
           (shell (str "clojure -M:jvm-base:migrate rollback " amount)))}

  rollback-all
  {:doc "Rollback all database migrations"
   :task (do
           (warning-msg "WARNING: This will rollback ALL migrations!")
           (info-msg "Rolling back all migrations...")
           (shell "clojure -M:jvm-base:migrate rollback-all"))}}}
