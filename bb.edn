{:deps {medley/medley
        {:mvn/version "1.3.0"}
        io.github.paintparty/bling
        {:mvn/version "0.6.0"}
        clj-commons/clj-yaml
        {:mvn/version "1.0.29"}}

 :paths ["src" "test"]

 :tasks
 {:requires ([babashka.fs :as fs]
             [bling.core :as bling]
             [babashka.process :as p]
             [clj-yaml.core :as yaml]
             [clojure.string :as str])

  ;; Build a specific prompt file by name
  build
  {:doc "Build a specific prompt file by name (without .md extension)\nUsage: bb build clojure_skill_builder"
   :task (let [name (or (first *command-line-args*)
                        (throw (ex-info "Usage: bb build <name>" {})))
               prompt (str "prompts/" name ".md")
               metadata (str "prompt_templates/" name ".yaml")
               output (str "_build/" name ".md")
               template "prompt_templates/combine.md"]

           (when-not (fs/exists? prompt)
             (throw (ex-info (str "Error: Prompt file not found: " prompt) {})))

           (when-not (fs/exists? metadata)
             (throw (ex-info (str "Error: Metadata file not found: " metadata) {})))

           (bling/callout
            {:type :info}
            (bling/bling [:bold (str "Building " output "...")]))

           (fs/create-dirs "_build")

           ;; Read skills from metadata YAML
           (let [meta-content (yaml/parse-string (slurp metadata))
                 skills (get meta-content :skills [])
                 skill-files (str/join " " skills)
                 pandoc-cmd (str "pandoc " prompt " " skill-files
                                 " --metadata-file=" metadata
                                 " --template=" template
                                 " -o " output)]

             (shell pandoc-cmd)

             (bling/callout
              {:type :success}
              (bling/bling [:bold (str "Build successful: " output)]))))}

  ;; Build all prompt files
  build-all
  {:doc "Build all prompt files"
   :task (do
           (bling/callout
            {:type :info}
            (bling/bling [:bold "Building all prompts..."]))

           ;; Build clojure_skill_builder
           (shell "bb build clojure_skill_builder")

           ;; Build clojure_build
           (shell "bb build clojure_build")

           (bling/callout
            {:type :success}
            (bling/bling [:bold "All builds complete!"])))}

  ;; Clean build artifacts
  clean-build
  {:doc "Clean all build artifacts from _build directory"
   :task (do
           (bling/callout
            {:type :info}
            (bling/bling [:bold "Cleaning _build directory..."]))

           (when (fs/exists? "_build")
             (doseq [f (fs/list-dir "_build")]
               (fs/delete f)))

           (bling/callout
            {:type :success}
            (bling/bling [:bold "Clean complete"])))}

  clean
  {:doc "Cleans the temp build files"
   :task (do
           (bling/callout
            {:type :info}
            (bling/bling [:bold "Running clean task"]))

           (fs/delete-tree "target")
           (fs/delete-if-exists "test-db.db")
           (fs/delete-if-exists "junit.xml")
           (fs/delete-if-exists "docs.html"))}

  test
  {:doc "Runs the projects with kocha"
   :task (do
           (bling/callout {:type :info}
                          (bling/bling [:bold "Running test task"]))

           (time
            (clojure "-M:jvm-base:dev:test")))}

  lint
  {:doc "Lints the code base with clj-kondo"
   :task (do
           (bling/callout
            {:type :info}
            (bling/bling [:bold "Running lint task"]))
           (time
            (clojure "-M:lint -m clj-kondo.main --lint dev src test")))}

  main {:doc "Run the main command line interface"
        :task (do
                (apply clojure (into ["-M:jvm-base:main"] *command-line-args*)))}

  outdated
  {:doc "Run command to detect outdate version of our deps"
   :task (clojure "-M:dev:outdated -m depot.outdated.main")}

  nrepl
  {:doc "Run a nRepl"
   :task
   (do
     (bling/callout
      {:type :info}
      (bling/bling [:bold "Running nRepl"]))
     (clojure "-M:jvm-base:dev:nrepl"))}

  fmt
  {:doc "Fix format clojure code"
   :task
   (do
     (clojure "-M:dev:format -m cljstyle.main fix scripts src dev"))}

  fmt-check
  {:doc "Check format clojure code"
   :task
   (do
     (clojure "-M:dev:format -m cljstyle.main check scripts src dev"))}

  typos
  {:doc "Check for typos in the codebase"
   :task (do
           (bling/callout
            {:type :info}
            (bling/bling [:bold "Checking for typos..."]))
           (shell "typos"))}

  typos-fix
  {:doc "Automatically fix typos in the codebase"
   :task (do
           (bling/callout
            {:type :info}
            (bling/bling [:bold "Fixing typos..."]))
           (shell "typos --write-changes"))}

  ci
  {:doc "Runs linting and tests for the CI"
   :task (do (run 'clean)
             (run 'fmt-check)
             (run 'lint)
             (run 'typos)
             (run 'test))}

  list-skills
  {:doc "List all skills with their paths and metadata"
   :task (let [skills-dir "skills"
               skill-files (sort (map str (fs/glob skills-dir "**/*.md")))

               ;; Function to extract YAML frontmatter
               extract-frontmatter (fn [file-path]
                                     (let [content (slurp file-path)
                                           lines (str/split-lines content)]
                                       (when (= "---" (first lines))
                                         (let [find-end (fn [lines]
                                                          (first (keep-indexed
                                                                  (fn [idx line]
                                                                    (when (and (> idx 0)
                                                                               (= "---" line))
                                                                      idx))
                                                                  lines)))
                                               end-idx (find-end lines)]
                                           (when end-idx
                                             (yaml/parse-string
                                              (str/join "\n" (take (dec end-idx) (drop 1 lines)))))))))

               ;; Parse all skills
               skills (for [file-path skill-files]
                        (let [metadata (extract-frontmatter file-path)
                              relative-path (str/replace file-path
                                                         (str (fs/file skills-dir) "/")
                                                         "")]
                          {:path file-path
                           :relative-path relative-path
                           :name (get metadata :name "unknown")
                           :description (get metadata :description "")}))

               ;; Group by category
               get-category (fn [skill] (first (str/split (:relative-path skill) (re-pattern "/"))))
               by-category (group-by get-category skills)]

           (bling/callout
            {:type :info}
            (bling/bling [:bold "Available Skills"]))

           (println)
           (println (bling/bling [:bold "Total Skills:"] (str (count skills))))
           (println)

           ;; Print organized by category
           (doseq [[category skill-list] (sort-by key by-category)]
             (println (bling/bling [:bold :cyan (str "## " (str/capitalize category))]))
             (doseq [skill (sort-by :name skill-list)]
               (println)
               (println (bling/bling [:bold "  Name:"] (:name skill)))
               (println (bling/bling "  Path:" (:path skill)))
               (when (seq (:description skill))
                 (let [desc (if (string? (:description skill))
                              (:description skill)
                              (str (:description skill)))
                       short-desc (if (> (count desc) 100)
                                    (str (subs desc 0 97) "...")
                                    desc)]
                   (println (bling/bling "  Desc:" short-desc)))))
             (println))

           ;; Also print as YAML-friendly list for prompt templates
           (println)
           (println (bling/bling [:bold :yellow "## For prompt_templates (copy this to .yaml):"]))
           (println)
           (println "skills:")
           (doseq [skill (sort-by :path skills)]
             (println (str "  - " (:path skill)))))}

  ;; LLMLingua compression tasks

  setup-python
  {:doc "Install Python dependencies using pipenv"
   :task (do
           (bling/callout
            {:type :info}
            (bling/bling [:bold "Installing Python dependencies with pipenv..."]))

           (shell "pipenv install")

           (bling/callout
            {:type :success}
            (bling/bling [:bold "Python environment ready!"]))

           (println)
           (println "You can now use:")
           (println "  bb compress <name> --ratio 10")
           (println "  bb build-compressed <name> --ratio 10")
           (println "  bb compress-skill skills/path/to/file.md --ratio 10"))}

  compress
  {:doc "Compress a built prompt file using LLMLingua\nUsage: bb compress clojure_skill_builder --ratio 10"
   :task (let [args *command-line-args*
               name (first args)
               ratio-idx (first (keep-indexed (fn [idx arg] (when (= "--ratio" arg) idx)) args))
               ratio-arg (when ratio-idx (nth args (inc ratio-idx) nil))
               ratio (if ratio-arg (parse-double ratio-arg) 10.0)

               input (str "_build/" name ".md")
               output (str "_build/" name ".compressed.md")]

           (when-not name
             (throw (ex-info "Usage: bb compress <name> [--ratio N]" {})))

           (when-not (fs/exists? input)
             (throw (ex-info (str "Error: Built file not found: " input
                                  "\nRun 'bb build " name "' first.") {})))

           (bling/callout
            {:type :info}
            (bling/bling [:bold (str "Compressing " input " with " ratio "x ratio...")]))

           ;; Run Python compression script via pipenv
           (let [result (shell {:out :string
                                :err :string
                                :continue true}
                               (str "pipenv run python scripts/compress_prompt.py"
                                    " --input " input
                                    " --output " output
                                    " --ratio " ratio))]
             (if (zero? (:exit result))
               (do
                 (println (:out result))
                 (bling/callout
                  {:type :success}
                  (bling/bling [:bold (str "Compression successful: " output)])))
               (do
                 (println (:err result))
                 (throw (ex-info "Compression failed" {:result result}))))))}

  compress-skill
  {:doc "Compress a single skill file\nUsage: bb compress-skill skills/libraries/data_validation/malli.md --ratio 10"
   :task (let [args *command-line-args*
               input-file (first args)
               ratio-idx (first (keep-indexed (fn [idx arg] (when (= "--ratio" arg) idx)) args))
               ratio-arg (when ratio-idx (nth args (inc ratio-idx) nil))
               ratio (if ratio-arg (parse-double ratio-arg) 10.0)

               ;; Create output path by adding .compressed before .md
               output-file (str/replace input-file (re-pattern "\\.md$") ".compressed.md")]

           (when-not input-file
             (throw (ex-info "Usage: bb compress-skill <path/to/skill.md> [--ratio N]" {})))

           (when-not (fs/exists? input-file)
             (throw (ex-info (str "Error: Skill file not found: " input-file) {})))

           (bling/callout
            {:type :info}
            (bling/bling [:bold (str "Compressing " input-file " with " ratio "x ratio...")]))

           (let [result (shell {:out :string
                                :err :string
                                :continue true}
                               (str "pipenv run python scripts/compress_prompt.py"
                                    " --input " input-file
                                    " --output " output-file
                                    " --ratio " ratio))]
             (if (zero? (:exit result))
               (do
                 (println (:out result))
                 (bling/callout
                  {:type :success}
                  (bling/bling [:bold (str "Compressed: " output-file)])))
               (do
                 (println (:err result))
                 (throw (ex-info "Compression failed" {:result result}))))))}

  build-compressed
  {:doc "Build and compress a prompt file\nUsage: bb build-compressed clojure_skill_builder --ratio 10"
   :task (let [args *command-line-args*
               name (first args)
               ratio-idx (first (keep-indexed (fn [idx arg] (when (= "--ratio" arg) idx)) args))
               ratio-arg (when ratio-idx (nth args (inc ratio-idx) nil))
               ratio (if ratio-arg ratio-arg "10")]

           (when-not name
             (throw (ex-info "Usage: bb build-compressed <name> [--ratio N]" {})))

           ;; Build first
           (shell (str "bb build " name))

           ;; Then compress
           (shell (str "bb compress " name " --ratio " ratio)))}}}